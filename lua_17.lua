-->>>Lua 垃圾回收

--Lua采用了自动内存管理。这意味着你不用操心新创建的对象需要的内存如何分配出来，也不用考虑对象不再使用后怎样释放他们所占用的内存
--Lua 运行一个垃圾收集器来收集所有的死对象(即在Lua中不可能再访问的对象)来完成自动内存管理的工作。
--Lua中所有用到的内存，如字符串、表、用户数据、函数、线程、内部结构等，都服从自动管理。
--Lua实现了一个增量标记-扫描收集器。由两个数字来控制垃圾收集循环：垃圾收集器歇率和垃圾收集步进倍率，这两个数字都是用百分数作为单位(例如:值100在内部表示1)
--垃圾收集器歇率控制这收集器需要开启新的循环前要等待多久：增大这个值会减少收集器的积极性。当这个值比100还小的时候，收集器在开启新的循环前不会有等待。
---------------设置这个值为200就会让收集器等到总内存使用量达到之前的两倍才开始新的循环。
--垃圾收集器步进倍率控制这收集器运行速度相对于内存分配速度的倍率：增大这个值不仅会让收集器更加积极，还会增加每个增量步骤的长度。不要把这个值设置小于100，那样的话收集器他工作就太慢了以至于用于完不成一个循环。
--垃圾收集器步进倍率默认值为200，这便是收集器以内存分配的两倍速度工作。

--1.垃圾收集器函数：
--Lua提供了以下函数collectgarbage([opt[,arg]])用来控制自动内存管理：
--1.1 collectgarbage("collect"):做一次完整的垃圾收集循环。通过参数opt它提供了一组不同的功能：
--1.2 collectgarbage("count"):以k字节数位单位返回Lua使用的总内存数。这个值由小鼠部分，所以只需要乘上1024就可以得到Lua使用的准确字节数
--1.3 collectgarbage("restart"):重启垃圾收集器的自动运行
--1.4 collectgarbage("setpause"):将arg设为收集器的间隙率，返回间隙率的前一个值
--1.5 collectgarbage("setstepmul"):返回步进倍率的前一个值
--1.6 collectgarbage("step"):单步运行垃圾收集器。步长大小由arg控制，传入0时，收集器步进(不可以分割)一步。传入非0时，收集器相当于Lua分配这么多内存的工作。如果收集器结束一个循环将将返回true
--1.7 collectgarbage("stop"):停止垃圾收集器的运行。在调用重启之前，收集器只会因显示的调用而运行。
--简单的垃圾收集器回收示例：
-- mytable={"apple","orangee","banana"}
-- print(collectgarbage("count"))
-- mytable=nil;
-- print(collectgarbage("count"));
-- print(collectgarbage("collect"));
-- print(collectgarbage("count"))
